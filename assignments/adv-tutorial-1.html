<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link id="github-css" rel="stylesheet" href="/assets/main.css"> </head> <title>Adv_tutorial_1</title> <body class="two-column"> <div class="wrapper"> <div id="sidebar" class="sidebar sticky-frame"> <ol class="side-menu"> <li><a href="#background">Background</a></li> <li> <a href="#intro">Intro</a><ol><li><a href="#procedural-shaders">Procedural shaders</a></li></ol> </li> <li><a href="#noise-functions">Noise functions</a></li> <li><a href="#part-1-writing-your-own-shaders">Part 1. Writing your own shaders</a></li> <li><a href="#part-2-writing-procedures-that-modify-shaders">Part 2. Writing procedures that modify shaders</a></li> <li><a href="#part-3-freestyle">Part 3. Freestyle</a></li> <li><a href="#part-4-extra-advanced">Part 4. Extra Advanced</a></li> <li><a href="#shaders">Shaders</a></li> <li> <a href="#submitting">Submitting</a><ol> <li><a href="#if-you-are-submitting-remotely">IF YOU ARE SUBMITTING REMOTELY</a></li> <li><a href="#if-you-are-in-class-or-at-alt-tutorial">IF YOU ARE IN CLASS OR AT ALT TUTORIAL</a></li> </ol> </li> </ol> </div> <article style="padding-left: 1em;"> <div class="main"> <object hidden="hidden" id="assignment-flag-custom"></object> <object hidden="hidden" id="canvas_id"></object> <object hidden="hidden" id="due_date">2024-10-02</object> <object hidden="hidden" id="canvas_assignment_group"></object> <object hidden="hidden" id="canvas_submission_types"></object> <object hidden="hidden" id="canvas_allowed_extensions"></object> <object hidden="hidden" id="canvas_points_possible"></object> <p>Thanks to Prof. Ian Horswill for the initial version of this assignment.</p> <p><a class="nu-button" href="https://bain-cs111.github.io/course-files/tutorials/adv_tutorial_1_template.zip" target="_blank"> Advance Tutorial 1 Starter Files <i class="fas fa-download"></i> </a></p> <h2 id="background">Background</h2> <p>So far in class, we’ve mentioned two different ways of representing images in computers. The 2D graphics language discussed in Lecture 2 represents pictures in terms of primitive shapes and transformations applied to them. These kinds of graphics systems are called <em>vector</em> or <em>object-oriented graphics</em>. Examples of commercial vector graphics systems are so-called “draw programs” like Adobe Illustrator and Corel Draw, but also presentation graphics systems like PowerPoint and Keynote, and animation systems like Macromedia Flash (RIP).</p> <p><em>Bitmap</em> or <em>raster graphics</em> are the other major type of representation. They represent images as mosaics of colored squares called <em>pixels</em> (short for picture elements). Since nearly all video displays and printers ultimately form pictures using pixels, even vector graphics are generally <em>rasterized</em> (i.e. converted to a pixel-form) when displayed on the screen.</p> <p>In this assignment, we’ll use a third kind of image representation: <strong>functions</strong>, aka <em>procedures</em>. <em>Procedural images</em> are a niche representation used primarily to represent the appearance of different kinds of materials like wood and marble in 3D computer graphics. In that context, they’re usually referred to as procedural textures, procedural shaders, or just shaders. Companies like Pixar have people who are wizards at writing shaders for different kinds of materials.</p> <h2 id="intro">Intro</h2> <p>Start by opening the file <code class="language-plaintext highlighter-rouge">adv_tutorial_1.rkt</code>.</p> <p>Now run the code in Tutorial 1 by pressing the <code class="language-plaintext highlighter-rouge">Run</code> button or typing <code class="language-plaintext highlighter-rouge">Command-R</code>. This will define a set of procedures that will let you write procedural shaders.</p> <blockquote> <p>Note: If you’re on a recent-ish computer running macOS, your computer will ask if DrRacket can have permission to access the folder in which your <code class="language-plaintext highlighter-rouge">adv_tutorial_1.rkt</code> file is stored. If you DENY that access, DrRacket won’t be able to load the two libraries we’ve provided for you: <code class="language-plaintext highlighter-rouge">shading.rkt</code> and <code class="language-plaintext highlighter-rouge">noise.rkt</code>.</p> </blockquote> <h3 id="procedural-shaders">Procedural shaders</h3> <p>Here’s the idea behind procedural shading. Ultimately, an image is just a variation of color over some surface where for any given position on the surface, there’s some specified color. In other words, a picture is in some sense a function from position to color. Rasters represent the function by breaking the surface up into little squares and assigning a color per square, but there’s nothing to prevent you from representing the image as a procedure that takes a location in the image as input and returns a color as output.</p> <p>Recall that in Racket, you create functions using <code class="language-plaintext highlighter-rouge">lambda</code> expressions, expressions of the form:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">argumentNames</span> <span class="o">...</span><span class="p">)</span> <span class="nv">returnValue</span><span class="p">)</span>
</code></pre></div></div> <p>The result of executing this expression is that it creates a function that takes its inputs and stashes them in variables with the specified <code class="language-plaintext highlighter-rouge">argumentNames</code>, and then runs the <code class="language-plaintext highlighter-rouge">returnValue</code> expression to compute the return value. If you like, you can then use <code class="language-plaintext highlighter-rouge">define</code> to give that function a name, but naming a function isn’t necessary, and in this exercise, you mostly won’t need to do it.</p> <p>So given that a shader is a function that maps position to color or brightness, our basic syntax for it will be something like:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">position</span><span class="p">)</span>
  <span class="nv">somethingToComputeTheColorForPoint</span><span class="p">)</span>
</code></pre></div></div> <p>where <code class="language-plaintext highlighter-rouge">somethingToComputeTheColorForPoint</code> can be any bit of Racket code you might want to write to compute the color for point.</p> <p>Let’s limit ourselves to black and white images for the moment. That means the procedure only needs to specify a brightness for the point, rather than a full color. The procedure can represent the brightness as a number between 0 (black) and 255 (the brightest value the monitor can produce).</p> <p>So a shader is a function that takes a position as an input and returns a number. The simplest example a shader is an image that’s black everywhere:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div> <p>That is, no matter what the position is, the brightness is always zero. We’ve included a procedure with this assignment called <code class="language-plaintext highlighter-rouge">render</code> that that rasterizes a shader for you and displays it. So if we type:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">render</span> <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div> <p><img src="/assets/adv_tutorial_1/screenshot_1.png" alt=""></p> <p>Admittedly, that’s is not a terribly interesting image, so let’s try a one that starts black on the left and gets gradually brighter as it moves to the right. The code for this is just <code class="language-plaintext highlighter-rouge">(λ (point) (point-x point))</code>. <code class="language-plaintext highlighter-rouge">point-x</code> is a procedure that takes a point as input and returns its X coordinate. The X coordinates start at 0 on the left and increase as you move right.</p> <p>Again, we can see the image by using render:</p> <p><img src="/assets/adv_tutorial_1/screenshot_2.png" alt=""></p> <p>As it happens, render makes 300x300 images, so on the right hand side, the X the image stops getting brighter once the X coordinates get to 255 (because 255 is the maximum possible brightness). This is sometimes referred to as <em>saturation</em> – the brightness goes outside the range that the display device can generate. The system does the same thing with “negative” brightnesses – it just treats them as 0.</p> <p>So we can get what draw programs sometimes call a “gradient” when we use the X coordinate for brightness. We can get what they call a “radial gradient” by taking the magnitude of the point (its distance from <code class="language-plaintext highlighter-rouge">(0,0)</code>, the upper-left-hand corner of the image):</p> <p><img src="/assets/adv_tutorial_1/screenshot_3.png" alt=""></p> <p>Here we use the magnitude procedure to get the magnitude of the point (distance from the upper-left corner), and again, the brightness saturates once we get more than 255 pixels from (0,0), that corner.</p> <blockquote> <p><strong>Arithmetic with points</strong></p> <p>Points can be used in arithmetic operations. The <code class="language-plaintext highlighter-rouge">point-*</code> procedure multiplies both coordinates of the point by the number. So multiplying the point (1,2) by 2 gives you the point (2,4). Multiplying points by numbers has the effect of stretching them away from the origin (the upper-left corner), but keeping their direction relative to the origin the same.</p> <p>The <code class="language-plaintext highlighter-rouge">point-+</code> procedure adds the coordinates of two points together, so that <code class="language-plaintext highlighter-rouge">(1, 2)+(5, 3)=(6, 5)</code>.</p> <p>You can also subtract points using the <code class="language-plaintext highlighter-rouge">point--</code> procedure.</p> </blockquote> <p>Alternatively, we could get a kind of concentric ring structure, like wood grain, if we took the sine of the distance rather than the distance itself as the brightness:</p> <p><img src="/assets/adv_tutorial_1/screenshot_4.png" alt=""></p> <p>Here we multiply the distance by a fudge factor (0.3) that we can use to adjust the spacing of the rings (bigger numbers mean more rings closer together), and we multiply the output of sin by a fudge factor to change the brightness of the image (bigger numbers mean brighter).</p> <h2 id="noise-functions">Noise functions</h2> <p>Procedural shading starts to get more interesting when we use noise functions. Noise functions are functions that vary “randomly” in some controlled way. The most popular noise function is based on the Perlin noise function, and is called the turbulence function. It’s used to create clouds and marble textures. Here’s an example of Perlin noise:</p> <p><img src="/assets/adv_tutorial_1/screenshot_5.png" alt=""></p> <p>Again, we multiply <code class="language-plaintext highlighter-rouge">point</code> by a fudge factor (0.01) to adjust the scale of the image. We multiply the output of the turbulence function by a different number (in this case 350) to adjust the brightness of the image (turbulence produces small numbers, which correspond to dark pixels). We can make the texture finer by increasing the multiplier on point from 0.01 to 0.02:</p> <p><img src="/assets/adv_tutorial_1/screenshot_6.png" alt=""></p> <p>Now everything from the previous image is shrunken into the upper left hand corner of the new image:</p> <p><img src="/assets/adv_tutorial_1/screenshot_7.png" alt=""></p> <p>The turbulence function is often used to render clouds. A standard turbulence function produces numbers for its output between -1 and +1 (actually, between about -0.8 and +0.8). Since the render procedure treats the negative “brightnesses” as just meaning normal black (the same as 0), the big black regions between the clouds are the regions where the turbulence function is returning zero or negative numbers. But we can make them visible, by rendering the absolute value of the turbulence function, so the negative regions become positive. This gives us something closer to a marble texture, and indeed, this is how marble surfaces are often rendered in computer graphics:</p> <p><img src="/assets/adv_tutorial_1/screenshot_8.png" alt=""></p> <p>Alternatively, we can use a <code class="language-plaintext highlighter-rouge">sin</code> function instead of <code class="language-plaintext highlighter-rouge">abs</code> to get something that looks almost like a topographic map:</p> <p><em>Normal version</em></p> <p><img src="/assets/adv_tutorial_1/screenshot_9.png" alt=""></p> <p><em>Absolute value</em> - fills in clouds between clouds (sort of like marble)</p> <p><img src="/assets/adv_tutorial_1/screenshot_10.png" alt=""></p> <p><em>Sine - clouds become contour maps</em></p> <p><img src="/assets/adv_tutorial_1/screenshot_11.png" alt=""></p> <h2 id="part-1-writing-your-own-shaders">Part 1. Writing your own shaders</h2> <p>For this part, we just want you to experiment with writing shaders and see what kinds of images they generate. There’s no fixed goal for this. Just try playing around.</p> <h2 id="part-2-writing-procedures-that-modify-shaders">Part 2. Writing procedures that modify shaders</h2> <p>Now that you’ve had a chance to experiment with writing shaders, we’re going to write procedures that work with shaders. These are procedures that take shaders as inputs and produce new shaders as outputs.</p> <ol> <li>Write a procedure, <code class="language-plaintext highlighter-rouge">brighten</code>, that takes as inputs a shader and a multiplier (a number), and returns as output a new shader whose output at any given point is the simply the output of the original shader at that point times the multiplier. So if we brighten a shader by 2, we get a new shader whose output is the original shader’s output times 2 (i.e. twice as bright).</li> </ol> <p>This kind of thing can be hard to communicate in text. So here’s a concrete example. We’ve included the cloud shader above under the name clouds. If you run <code class="language-plaintext highlighter-rouge">(brighten clouds 2)</code>, you should get the the same clouds, only twice as bright. If you run <code class="language-plaintext highlighter-rouge">(brighten clouds 0.5)</code>, it should be half as bright:</p> <p><img src="/assets/adv_tutorial_1/screenshot_12.png" alt=""></p> <p><img src="/assets/adv_tutorial_1/screenshot_13.png" alt=""></p> <p><img src="/assets/adv_tutorial_1/screenshot_14.png" alt=""></p> <p>So where <code class="language-plaintext highlighter-rouge">clouds</code> returns 50 for some point (i.e. 50 units of brightness), <code class="language-plaintext highlighter-rouge">(brighten clouds 2)</code> should return 100 and <code class="language-plaintext highlighter-rouge">(brighten clouds 0.5)</code> should return 25.</p> <p>To do this problem, you want to write <code class="language-plaintext highlighter-rouge">brighten</code> so that it returns a shader. But a shader is just a procedure that takes a point as input and returns a brightness. So you want to write a procedure whose output is itself a procedure, in particular a λ expression:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">brighten</span>
   <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">shader</span> <span class="nv">multiplier</span><span class="p">)</span>
     <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span>
       <span class="nv">something</span><span class="p">)))</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">(λ (point) something)</code> here is the new shader being returned by <code class="language-plaintext highlighter-rouge">brighten</code>. It takes an argument, <code class="language-plaintext highlighter-rouge">point</code>, as input and then needs to compute the brightness for the image at that location. How does it compute that brightness? We’ll it’s just the brightness of the original shader times multiplier. But how does it know what the brightness of the original shader is? It just calls it: <code class="language-plaintext highlighter-rouge">(shader point)</code>.</p> <ol> <li>Now write a procedure, <code class="language-plaintext highlighter-rouge">negative</code>, that gives you a negative image (in the sense of a negative from old film camera) of a shader, so that what was white in the original shader is now black, and what was black is now white: if the original shader returns 0 at a point, the new one should return 255 and vice versa. More generally, if the original shader returns some number <code class="language-plaintext highlighter-rouge">x</code> at a point, the new shader should return the number <code class="language-plaintext highlighter-rouge">255-x</code>. Again, here’s an example with clouds:</li> </ol> <p><img src="/assets/adv_tutorial_1/screenshot_15.png" alt=""></p> <ol> <li>Now write a procedure, <code class="language-plaintext highlighter-rouge">zoom</code>, that takes a shader and a scale factor as input, and it returns a shader that’s magnified (in the sense of grown, not brightened) by that factor, like this:</li> </ol> <p><img src="/assets/adv_tutorial_1/screenshot_16.png" alt=""></p> <p><img src="/assets/adv_tutorial_1/screenshot_17.png" alt=""></p> <p><img src="/assets/adv_tutorial_1/screenshot_18.png" alt=""></p> <p><code class="language-plaintext highlighter-rouge">zoom</code> is like <code class="language-plaintext highlighter-rouge">brighten</code>, except that instead of multiplying the output of the original shader (that is, multiplying the brightness), it divides its input. So in order words, instead of calling shader with <code class="language-plaintext highlighter-rouge">point</code> as its input, it calls it with:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">point-/</span> <span class="nv">point</span> <span class="nv">scale-factor</span><span class="p">)</span>
</code></pre></div></div> <p>as its input. <code class="language-plaintext highlighter-rouge">point-/</code> is a procedure that makes a new point from the original one, but divides each coordinate by the scale factor.</p> <p>You might think that you’d want to multiply the point by the scale factor rather than divide by it (I did when I first wrote it). But try both (or think it through) and you’ll see that you actually want to divide.</p> <ol> <li>Now write a procedure, <code class="language-plaintext highlighter-rouge">slide</code>, that shifts a shader’s image by a specified amount. In particular, slide should take a shader and a point as inputs, and return a new shader that looks like the original, but where whatever was previously at (0,0) is now shifted to the specified point. For example:</li> </ol> <p><img src="/assets/adv_tutorial_1/screenshot_19.png" alt=""></p> <p><img src="/assets/adv_tutorial_1/screenshot_20.png" alt=""></p> <p><img src="/assets/adv_tutorial_1/screenshot_21.png" alt=""></p> <p>You solve this one like <code class="language-plaintext highlighter-rouge">zoom</code>, in that you make a new shader that calls the old shader with a different point as input. However, in this case, instead of calling it with <code class="language-plaintext highlighter-rouge">(point-/ point scale-factor)</code> as its input, you call it with <code class="language-plaintext highlighter-rouge">(point-- point offset)</code>, where offset is the amount we want to shift the image by. Again, you might think you’d want to add the <code class="language-plaintext highlighter-rouge">offset</code> to the original point, but if you try it you’ll see that subtracting is the right thing to do.</p> <ol> <li>Finally, write a procedure, <code class="language-plaintext highlighter-rouge">mix</code>, that takes two shaders as inputs and returns a new shader whose brightness at a point is the average of the brightnesses of the two shaders, so that it does a kind of double-exposure. Here we’ll demonstrate it with two other shaders we’ve included with the assignment file, <code class="language-plaintext highlighter-rouge">vertical-bars</code> and <code class="language-plaintext highlighter-rouge">horizontal-bars</code>, that just create sine wave patterns:</li> </ol> <p><img src="/assets/adv_tutorial_1/screenshot_22.png" alt=""> <img src="/assets/adv_tutorial_1/screenshot_23.png" alt=""> <img src="/assets/adv_tutorial_1/screenshot_24.png" alt=""></p> <h2 id="part-3-freestyle">Part 3. Freestyle</h2> <p>Now just play around and have fun. See what kinds of images you can make!</p> <h2 id="part-4-extra-advanced">Part 4. Extra Advanced</h2> <p>Write a procedure, <code class="language-plaintext highlighter-rouge">morph</code>, that takes a shader and a function as input and returns a new shader based on the original shader, but deformed based on the function. Here’s what we mean. If you say <code class="language-plaintext highlighter-rouge">(morph shader f)</code>, where <code class="language-plaintext highlighter-rouge">f</code> is function from points to points, then you should get back a new shader who’s value at a point <code class="language-plaintext highlighter-rouge">p</code> is just <code class="language-plaintext highlighter-rouge">(shader (f p))</code>.</p> <p>Morphing is used a lot in graphics. For example, zooming and shifting are just special cases of morphing:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">zoom</span>
   <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">shader</span> <span class="nv">magnification</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">morph</span> <span class="nv">shader</span>
             <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-*</span> <span class="nv">magnification</span> <span class="nv">p</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">shift</span>
   <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">shader</span> <span class="nv">point</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">morph</span> <span class="nv">shader</span>
             <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">point--</span> <span class="nv">p</span> <span class="nv">point</span><span class="p">)))))</span>
</code></pre></div></div> <p>But we can also do some more sophisticated operations. For example, the noise-vector procedure makes a random vector that can be added to a point, shifting it slightly around. If we use this to morph an image, we get a crinkling effect:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">crinkle</span>
     <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">shader</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">morph</span> <span class="nv">shader</span>
              <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">p</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">point-+</span> <span class="nv">p</span>
                         <span class="p">(</span><span class="nf">noise-vector</span> <span class="nv">p</span> <span class="mi">10</span> <span class="mf">0.1</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">render</span> <span class="p">(</span><span class="nf">crinkle</span> <span class="nv">horizontal-bars</span><span class="p">))</span>
</code></pre></div></div> <p><img src="/assets/adv_tutorial_1/screenshot_25.png" alt=""></p> <p>In the code above, 10 is a multiplier that controls how big the noise vector is. Make it bigger and the image will get more distorted. Make it smaller, and it will become less distorted. The 0.1 is a scale factor that controls how fast the noise vector changes from pixel to pixel. The bigger it is, the faster it changes, and so in a certain sense the smaller the “scale” of the distortion. I know that’s confusing to read in English, but if you play with the numbers, you’ll get the idea.</p> <h2 id="shaders">Shaders</h2> <p>Much of the appearance of objects in 3D graphics comes from “texture mapping” where texture images are “wrapped” around objects like wallpaper. The exact process for this is outside the scope of this class, but the basic idea is the artist designing an object chooses a texture image for each object, and assigns a location in the image to each point on the object’s surface. When the system renders (draws) the object, it determines where on the screen the object is, and for each screen pixel in that region, it determines the coordinates of that pixel on the surface of the object, then from that determines the coordinates in the texture image. The system then runs the shader to determine the color that should appear at that point.</p> <p><img src=""> <img src="/assets/adv_tutorial_1/screenshot_26.png" alt=""></p> <p>The image above (from <a href="http://www.noisemachine.com/talk1/index.html" rel="external nofollow noopener" target="_blank">Ken Perlin’s web site</a>) shows four different noise textures, both as flat images, and as textures mapped onto the surface of a sphere.</p> <h2 id="submitting">Submitting</h2> <p><mark>Regardless of how you choose to complete the assignment, you MUST submit the file you worked on to Canvas. Do that now. Since you're working on an advanced tutorial, make sure the string <code>adv</code> appears somewhere in your file name.</mark></p> <h3 id="if-you-are-submitting-remotely">IF YOU ARE SUBMITTING REMOTELY</h3> <p>Then your file will be graded for completeness and correctness.</p> <p>Before turning your assignment in, <strong>run the file one last time</strong> to make sure that it runs properly and doesn’t generate any exceptions. You might also take a look at the Autograder/Submission FAQs on Canvas under the <code>Class Resources</code> page. Once you’ve submitted your file to Canvas, you’ve completed the assignment.</p> <h3 id="if-you-are-in-class-or-at-alt-tutorial">IF YOU ARE IN CLASS OR AT ALT TUTORIAL</h3> <p>Then your file will be graded for participation along with what we call a ‘peer review.’ Find one other person in your group that is finished and peer review each other’s work. Here are the things to check:</p> <ol> <li>Does their code look readable and neat?</li> <li>Can you understand what their code does by reading it?</li> <li>How was their solution different from yours (if at all)?</li> <li>Does their program run and generate the correct test images?</li> </ol> <p>Once you’ve each taken a look, take a second to debrief. Anything either of you found difficult? Easy? Fun? Mind-blowing?</p> <p>Once you’ve debriefed, <strong>both of you should fill out this</strong> <a href="https://docs.google.com/forms/d/e/1FAIpQLSd6RMZwNmhSSENCqJVfUE7jwkg9IcBXgQgnsJWur7YIM9yy2g/viewform?usp=sf_link" target="_blank" rel="external nofollow noopener">attendance Google Form</a>. <strong>NOTE: You will need the NetID of the person’s whose code you reviewed.</strong></p> <p>You’re free to go after you’re finished, though we hope that you might consider sticking around and helping others in your group.</p> </div> </article> </div> </body> </html>