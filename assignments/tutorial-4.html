<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link id="github-css" rel="stylesheet" href="/assets/main.css"> </head> <title>Tutorial 4</title> <body class="two-column"> <div id="nav-bar"> <a href="#submitting">Submitting</a><a href="#getting-started">Getting Started</a><a href="#part-1-factorial">Part 1</a><a href="#part-2-count-odd">Part 2</a><a href="#sussman-form">Sussman Form</a><a href="#part-3-count">Part 3</a><a href="#part-4-seeing-the-trees-from-the-forest">Part 4</a> </div> <article> <div class="main" style="max-height: 100vh;"> <object hidden="hidden" id="assignment-flag-custom"></object> <object hidden="hidden" id="canvas_id">1482914</object> <object hidden="hidden" id="due_date">2024-10-23</object> <object hidden="hidden" id="canvas_assignment_group">Tutorials</object> <object hidden="hidden" id="canvas_submission_types">online_upload</object> <object hidden="hidden" id="canvas_allowed_extensions">rkt</object> <object hidden="hidden" id="canvas_points_possible">100</object> <blockquote> <p>Note: For groups that may have a significant amount of programming experience, your PM may suggest trying out the <a target="blank" href="https://bain-cs111.github.io/assignments/adv-tutorial-4">Advanced Tutorial 4</a></p> </blockquote> <h2 id="submitting">Submitting</h2> <p><mark>Regardless of how you choose to complete the assignment, you MUST submit the file you worked on to Canvas.</mark></p> <h3 id="if-you-are-submitting-remotely">IF YOU ARE SUBMITTING REMOTELY</h3> <p><em>If you‚Äôre submitting remotely</em>, your submitted file will be graded for completeness and correctness via an autograder. Make sure your functions are named as the assignment specifies <mark>exactly</mark>.</p> <h3 id="if-you-are-in-class-or-at-an-alt-tutorial">IF YOU ARE IN CLASS OR AT AN ALT TUTORIAL</h3> <p>Then your file will be graded for participation (i.e. it‚Äôs okay if you haven‚Äôt finished the entire thing because you may have spent time asking a question; helping a friend; etc.) along with what we call a ‚Äòpeer review.‚Äô Find one other person in your group that is finished and peer review each other‚Äôs work. Here are the things to check:</p> <ol> <li>Does their code look readable and neat?</li> <li>Can you understand what their code does by reading it?</li> <li>How was their solution different from yours (if at all)?</li> <li>Does their program run and generate the correct results?</li> </ol> <p>Once you‚Äôve debriefed, <mark><b>both of you should fill out this</b> <a href="https://docs.google.com/forms/d/e/1FAIpQLSd6RMZwNmhSSENCqJVfUE7jwkg9IcBXgQgnsJWur7YIM9yy2g/viewform?usp=sf_link" target="_blank" rel="external nofollow noopener">attendance Google Form</a>. NOTE: You will need the NetID of the person's whose code you reviewed. This form will only be available near the end of the tutorial session.</mark></p> <hr> <h2 id="getting-started">Getting Started</h2> <p>Today‚Äôs tutorial is all about practicing recursion. Remember, <strong>recursion</strong> itself is a very simple concept: a function is <strong>recursive</strong> if it calls itself in its definition. In all of these, we AREN‚ÄôT using our list iterators (e.g. <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">map</code>, etc.). Instead, we‚Äôre building these functions from the ground up!</p> <p><a href="https://thomaspark.co/2017/01/relevant-xkcd/" rel="external nofollow noopener" target="_blank">Relevant ‚ÄúXKCD‚Äù Comic Strip</a> (totally worth a click):</p> <p><img alt="XKCD Comic About Recursion" src="https://bain-cs111.github.io/assets/tutorial_4/xkcd.png" style="width: 75%;"></p> <p>There are no template files for this Tutorial so you‚Äôll need to start from a blank DrRacket file. You can do this by either just opening DrRacket and it‚Äôll open a new <code class="language-plaintext highlighter-rouge">Untitled</code> file or if you already have DrRacket open, you can go to the File menu and hit <code class="language-plaintext highlighter-rouge">New</code> or <code class="language-plaintext highlighter-rouge">New Tab</code>.</p> <p>After you‚Äôve got a blank document open (make sure you‚Äôve got your language chooser line at the top <code class="language-plaintext highlighter-rouge">#lang htdp/isl+</code>), might as well save it with a good sensible name somewhere on your computer where you store important docs.</p> <hr> <h2 id="part-1-factorial">Part 1. <code class="language-plaintext highlighter-rouge">factorial</code> </h2> <p>Write the <strong>factorial</strong> function <code class="language-plaintext highlighter-rouge">n!</code> as a <strong>recursive</strong> function. The factorial of a number is the product of all the numbers from one to that number:</p> <p><img style="width:40%;" src="https://bain-cs111.github.io/assets/tutorial_4/factorial_1.png" alt="a mathematical description of the factorial function"></p> <p>and so on. Here are some subgoals to accomplish on your way to writing the function:</p> <p><em>Subgoal 1</em>. What is the type of <code class="language-plaintext highlighter-rouge">factorial</code> (that is, what is its type signature, the types of its input and output)?</p> <p><em>Subgoal 2</em>. What is the purpose statement for it? Can you write some tests (<code class="language-plaintext highlighter-rouge">check-expect</code>s) to make sure it works?</p> <p><em>Subgoal 3</em>. What should the <strong>base case</strong> be (aka the ‚Äúeasy case‚Äù) for the recursion. The base case is an input for the function where you know the answer without having to recurse. What‚Äôs a really easy input to compute the factorial of?</p> <p>Hint: what‚Äôs <code class="language-plaintext highlighter-rouge">1!</code>?</p> <p><em>Subgoal 4</em>. Now time to implement that base case. Write inside your function (this is just a temporary ‚Äústub‚Äù):</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span> <span class="nv">test-for-base-case</span>
    <span class="nv">answer-for-base-case</span>
    <span class="nv">TODO</span><span class="p">)</span>
</code></pre></div></div> <p>Now replace <code class="language-plaintext highlighter-rouge">test-for-base-case</code> with something that looks at the input to the function and determines if it‚Äôs the base-case input, and answer-for-base-case is the answer for the base case. We‚Äôll fill in <code class="language-plaintext highlighter-rouge">TODO</code> in a minute.</p> <blockquote> <p>Hint (again): Let‚Äôs say you named your input to the function <code class="language-plaintext highlighter-rouge">n</code>. If we know that <code class="language-plaintext highlighter-rouge">(factorial 1)</code> should be <code class="language-plaintext highlighter-rouge">1</code> cause <code class="language-plaintext highlighter-rouge">1!</code> is 1‚Ä¶and we know that <code class="language-plaintext highlighter-rouge">1!</code> is our ‚Äúsimplest‚Äù (base) case‚Ä¶then all we need to do is test to see if <code class="language-plaintext highlighter-rouge">n</code> is <code class="language-plaintext highlighter-rouge">=</code> to <code class="language-plaintext highlighter-rouge">1</code>. If it is‚Ä¶then our function should just return <code class="language-plaintext highlighter-rouge">1</code>.</p> </blockquote> <p><em>Subgoal 5</em>. What‚Äôs the <strong>recursive case</strong>? The recursive case is what runs when the input is anything that‚Äôs NOT the base case. Basically, our goal is to call ourselves (i.e. <code class="language-plaintext highlighter-rouge">factorial</code>) with a new input that‚Äôs ‚Äúone step closer‚Äù to the base case. Once we get that answer back (it could take a lot of recursions), we‚Äôll take the answer to that and turn it into the answer for the original problem.</p> <p>You‚Äôll need to decide two things:</p> <ul> <li>How do you make the input to <code class="language-plaintext highlighter-rouge">factorial</code> be ‚Äúone step closer‚Äù to your base case?</li> <li>If you had the answer for the ‚Äúone step closer‚Äù input, how would you use it to solve for the original input?</li> </ul> <blockquote> <p>Hint: how would you make <code class="language-plaintext highlighter-rouge">3!</code> one step closer to <code class="language-plaintext highlighter-rouge">1!</code>? Wait a second‚Ä¶isn‚Äôt <code class="language-plaintext highlighter-rouge">3!</code> the same thing as <code class="language-plaintext highlighter-rouge">3 * 2!</code>? And isn‚Äôt <code class="language-plaintext highlighter-rouge">2!</code> the same thing as <code class="language-plaintext highlighter-rouge">2 * 1!</code>?</p> </blockquote> <p><em>Subgoal 6</em>. Now fill in the part in your code that says TODO:</p> <ul> <li>Write your recursive call, i.e. <code class="language-plaintext highlighter-rouge">(factorial easier-input)</code> where <code class="language-plaintext highlighter-rouge">easier-input</code> is whatever the easier version of the input is</li> <li> <code class="language-plaintext highlighter-rouge">easier-input</code> will look some thing like this <code class="language-plaintext highlighter-rouge">(some-math-op input-number another-number)</code> </li> <li>Then change it to <code class="language-plaintext highlighter-rouge">(fixit (factorial easier-input))</code> where <code class="language-plaintext highlighter-rouge">fixit</code> is something that transforms the answer to <code class="language-plaintext highlighter-rouge">(factorial easier-input)</code> into the answer for the original input.</li> </ul> <blockquote> <p><strong>Note</strong>: our notation here is a little misleading because it makes it look like <code class="language-plaintext highlighter-rouge">fixit</code> should just be the name of a function. But for this problem, you‚Äôll want to pass an additional argument to the function besides the result from the recursive call. That means for this problem, the form will really be:</p> <div class="language-racket highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">some-function</span> <span class="nv">some-argument</span>
               <span class="p">(</span><span class="nf">factorial</span> <span class="nv">easier-input</span><span class="p">))</span>
</code></pre></div> </div> </blockquote> <blockquote> <p><strong>Hint</strong>: Remember, that a factorial can be expressed like this: <code class="language-plaintext highlighter-rouge">5! = (5 - 0) * 4! = (5 - 0) * (5 - 1) * 3! = ...</code></p> </blockquote> <p>Nice work! You‚Äôve officially written a recursive function. Remember that all you need to do is: 1. find a base case; 2. think of a way of getting the original input ‚Äúone step closer‚Äù to the base case at a time; and 3. think of a way to combine the results to the ‚Äúone step closer‚Äù problems into the larger problem.</p> <p><a href="https://bain-cs111.github.io/course-files/tutorials/tutorial_4/factorial_walkthrough.rkt">Having trouble? See if this walkthrough step-by-step helps.</a></p> <hr> <h2 id="part-2-count-odd">Part 2. <code class="language-plaintext highlighter-rouge">count-odd</code> </h2> <p>Write a function</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">count-odd:</span> <span class="p">(</span><span class="nf">listof</span> <span class="nv">number</span><span class="p">)</span> <span class="nv">-&gt;</span> <span class="nv">number</span>
</code></pre></div></div> <p>that returns the number of odd elements in a list of numbers. Remember that you can determine if a number is odd by calling the predicate <code class="language-plaintext highlighter-rouge">odd?</code>.</p> <p><em>Subgoal 1</em>. We‚Äôve already given you a type for <code class="language-plaintext highlighter-rouge">count-odd</code>. So write a type signature comment.</p> <p><em>Subgoal 2</em>. Now write a purpose statement in your own words. Don‚Äôt start writing code before you start thinking about what you‚Äôre trying to accomplish! Can you write some <code class="language-plaintext highlighter-rouge">check-expect</code>s to verify it works as you might imagine?</p> <p><em>Subgoal 3</em>. Okay, now what‚Äôs the base case? Again, this is a case that‚Äôs so easy we don‚Äôt have to do much. What would be a <code class="language-plaintext highlighter-rouge">list</code> where you‚Äôd just know the answer?</p> <p><em>Subgoal 4</em>. Write your skeleton for a simple recursion:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span> <span class="nv">base-case</span>
    <span class="nv">base-case-answer</span>
    <span class="nv">TODO</span><span class="p">)</span>
</code></pre></div></div> <p>and fill in the first two parts.</p> <p><em>Subgoal 5</em>. Now what‚Äôs your recursive case? Again, this has two parts:</p> <ul> <li>What‚Äôs an easier input that‚Äôs ‚Äúone step closer‚Äù to your base case?</li> <li>How do you transform the answer for the easier input into the answer for the original input? Transforming the answer for this one is a little more complicated because it requires its own <code class="language-plaintext highlighter-rouge">if</code> expression.</li> </ul> <blockquote> <p><strong>Note</strong>: It might be useful to remember two convenient <code class="language-plaintext highlighter-rouge">list</code> functions, <code class="language-plaintext highlighter-rouge">first</code> which returns the first element of a given list and <code class="language-plaintext highlighter-rouge">rest</code> which returns all of the elements <em>except</em> the first one. Check it out in the documentation or in our function glossary.</p> </blockquote> <p><em>Subgoal 6</em>. Finally, fill in the <code class="language-plaintext highlighter-rouge">TODO</code> part with your full recursive case. Normally, the recursive case would look something like:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">fixit</span> <span class="p">(</span><span class="nf">count-odd</span> <span class="nv">easier-input</span><span class="p">))</span>
</code></pre></div></div> <p>However, since the <code class="language-plaintext highlighter-rouge">fixit</code> part here needs to involve an <code class="language-plaintext highlighter-rouge">if</code> expression that will use the answer from the recursive step a few different times, it‚Äôs probably easier to put the result of the recursive call into a local variable using the <code class="language-plaintext highlighter-rouge">local</code> expression.</p> <p>Your code will look something like:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span> <span class="nv">base-case</span>
    <span class="nv">base-case-answer</span>
    <span class="p">(</span><span class="nf">local</span> <span class="p">[(</span><span class="k">define</span> <span class="nv">recursive-answer</span> <span class="p">(</span><span class="nf">count-odd</span> <span class="nv">easier-input</span><span class="p">))]</span>
           <span class="p">(</span><span class="k">if</span> <span class="nv">something-is-true</span>
               <span class="nv">do-something</span>
               <span class="nv">do-something-else</span><span class="p">)))</span>
</code></pre></div></div> <p>And then <code class="language-plaintext highlighter-rouge">recursive-answer</code> will get used inside of two of the <code class="language-plaintext highlighter-rouge">do-something</code>s.</p> <p>Wow, you‚Äôre good at this! Two down, two to go!</p> <hr> <h2 id="sussman-form">Sussman Form</h2> <p>So, as is the case with many classes‚Ä¶we‚Äôve been lying to you for the last few weeks. You know how I said you HAD to use <code class="language-plaintext highlighter-rouge">lambda</code> or the <code class="language-plaintext highlighter-rouge">Œª</code> to define a function? Totally not true. Say you have a function like this:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">i-am-so-cool</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">an-input</span><span class="p">)</span>
    <span class="nv">do-something-cool</span><span class="p">))</span>
</code></pre></div></div> <p>You can actually use <strong>Sussman form</strong> as a short hand for this same definition by doing the following:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">i-am-so-cool</span> <span class="nv">an-input</span><span class="p">)</span>
  <span class="nv">do-something-cool</span><span class="p">)</span>
</code></pre></div></div> <p>These two things are completely equivalent. In fact, Racket will run your code in the second example‚Ä¶add the <code class="language-plaintext highlighter-rouge">lambda</code> expression back in to your code and then run it as normal. <em>There is never a case where you <strong>have</strong> to use Sussman form.</em> However, you‚Äôll start seeing it in our solutions files from now on as it‚Äôs just a tad faster than having to type lambda.</p> <p>So in the general case, a function in Sussman form just looks like this:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">function-name</span> <span class="nv">input-1</span> <span class="nv">input-2</span> <span class="o">...</span><span class="p">)</span>
  <span class="nv">output-expression</span><span class="p">)</span>
</code></pre></div></div> <p>One last example just to make sure you see the difference in notation. These two function definitions are EXACTLY the same:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">f</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
</code></pre></div></div> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div> <p>Like I said, you don‚Äôt <strong>have</strong> to use Sussman form. But it is quicker to type‚Ä¶so see if you like it in the next couple of problems.</p> <hr> <h2 id="part-3-count">Part 3. <code class="language-plaintext highlighter-rouge">count</code> </h2> <p>Now abstract your answer from the previous question to make a function</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">count:</span> <span class="p">(</span><span class="nf">T</span> <span class="nv">-&gt;</span> <span class="nv">Boolean</span><span class="p">)</span> <span class="p">(</span><span class="nf">listof</span> <span class="nv">T</span><span class="p">)</span> <span class="nv">-&gt;</span> <span class="nv">number</span>
</code></pre></div></div> <p>that takes a <code class="language-plaintext highlighter-rouge">list</code>, but also a <strong>predicate</strong>, and returns the number of elements in the list that the predicate returns <code class="language-plaintext highlighter-rouge">true</code>. For example, <code class="language-plaintext highlighter-rouge">(count odd? my-list)</code> should do the same thing as <code class="language-plaintext highlighter-rouge">(count-odd my-list)</code>.</p> <p>Good news! This does not require coming up with a new base case or recursive case. It requires only abstracting your code (remember, abstraction is both powerful and cool). That is, you should:</p> <ul> <li>Copy your code for <strong>Problem 2</strong> </li> <li>Change the name of the function</li> <li>Add an extra input to the function so that the user can input a predicate</li> <li>Change the code so that instead of always using <code class="language-plaintext highlighter-rouge">odd?</code> it instead uses the predicate the user specified. (Make sure to change the <code class="language-plaintext highlighter-rouge">recursive-answer</code>!)</li> <li>Make sure to write some tests for your new function!</li> </ul> <p>Wow. Abstraction <strong>and</strong> recursion. This is straight üî•. Better call the üöí.</p> <hr> <h2 id="part-4-seeing-the-trees-from-the-forest">Part 4. Seeing the <code class="language-plaintext highlighter-rouge">tree</code>s from the Forest</h2> <p>Write a recursive function, <code class="language-plaintext highlighter-rouge">tree</code>, that makes a recursive image something like this:</p> <p><img alt="Image of a cool tree" src="https://bain-cs111.github.io/assets/tutorial_4/tree.svg" style="width:50%;"></p> <p>How do you make something like this? Here‚Äôs the basic idea:</p> <ul> <li>At its base, it‚Äôs just a solid green rectangle</li> <li>Then, we have just two solid green rectangles rotated at say a 45 degree angle</li> <li>REPEAT FOR ALL GREEN RECTANGLES (until you feel like stopping)</li> </ul> <p>Another way of describing it is that tree is a stick for the trunk and then two simpler trees sticking out of it at angles. Those simpler trees are each sticks with two simpler trees sticking out of them at angles. And so on, and so on, until eventually it just draws a stick.</p> <p>We can write that as a recursion. The function <code class="language-plaintext highlighter-rouge">tree</code> takes a number of levels of branching (levels of recursion) and gives you back an <code class="language-plaintext highlighter-rouge">image</code> of that tree with that number of levels. So zero levels of branching is just a stick. One level of branching is a Y shape (a stick with two sticks pointing out of it), two levels of branching is a Y where the branches on top each each Y‚Äôs themselves, and so on. That means:</p> <ul> <li>A tree with zero levels of branching is a stick</li> <li>A tree with <code class="language-plaintext highlighter-rouge">n</code> levels of branching is a stick with two subtrees that have <code class="language-plaintext highlighter-rouge">n-1</code> levels of branching</li> </ul> <p>Here‚Äôs what your function should (roughly) produce across inputs from 0 levels of branching up to 9 levels:</p> <p><img alt="Trees at Different Levels from 0 to 9" src="https://bain-cs111.github.io/assets/tutorial_4/tree-sequence.svg" style="width:75%;"></p> <p>Your trees don‚Äôt have to look exactly like ours‚Äìthat would require a lot of trial and error that you wouldn‚Äôt learn anything from. Just experiment with making recursive pictures like this and have fun. You can make some absolutely dope images with this simple pattern.</p> <blockquote> <p><strong>Note</strong>: remember that you‚Äôll need to add <code class="language-plaintext highlighter-rouge">(require 2htdp/image)</code> to your file to get access to the graphics functions.</p> </blockquote> <p>Time for some subgoals:</p> <ul> <li>As always, what is the type of the function? That is, what type of input does it expect and what type of output does it generate? Remember that the input is the number of levels of branching (i.e. number of levels of recursion).</li> <li>Write a type signature comment.</li> <li>What is it trying to do in your own words?</li> <li>Write a purpose statement (it‚Äôs hard to write tests for this sort of image function, so instead try to imagine what sort of images you SHOULD see as soon as your program starts working)</li> <li>What‚Äôs your base case? That is, for what number of levels of branching do you not need to recurse at all? And what do you return then?</li> <li>What‚Äôs your recursive case?</li> <li>What‚Äôs the ‚Äúone step closer‚Äù number of levels of branching that brings you closer to the base case?</li> <li>When you recurse, you‚Äôre going to make a subtree and you‚Äôre going to paste it into the final output twice. So you might as well do just one recursive call and put it in a local variable using local. So write something that looks like:</li> </ul> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">(</span><span class="nf">local</span> <span class="p">[(</span><span class="k">define</span> <span class="nv">subtree</span> <span class="p">(</span><span class="nf">tree</span> <span class="nv">simpler-input</span><span class="p">))]</span>
    <span class="nv">TODO</span><span class="p">)</span>
</code></pre></div></div> <blockquote> <p>Note: that is NOT a function definition in Sussman form. That is storing the result of running <code class="language-plaintext highlighter-rouge">(tree simpler-input)</code> in the local variable subtree</p> </blockquote> <ul> <li>Finally, you need to fill in <code class="language-plaintext highlighter-rouge">TODO</code> with something that makes the subtree itself by assembling the two copies of the subtree with a trunk. Rather than make you fiddle for a long time, here‚Äôs the basic structure, which is:</li> </ul> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">above</span> <span class="p">(</span><span class="nf">beside</span> <span class="p">(</span><span class="nf">rotate</span> <span class="nv">angle</span> <span class="p">(</span><span class="nf">scale</span> <span class="nv">factor</span> <span class="nv">subtree</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">rotate</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">-1</span> <span class="nv">angle</span><span class="p">)</span> <span class="p">(</span><span class="nf">scale</span> <span class="nv">factor</span> <span class="nv">subtree</span><span class="p">)))</span>
       <span class="p">(</span><span class="nf">rectangle</span> <span class="o">...</span> <span class="nv">some</span> <span class="nv">pretty</span> <span class="nv">args</span> <span class="o">...</span><span class="p">))</span>
</code></pre></div></div> <p>Pick whatever <code class="language-plaintext highlighter-rouge">angle</code> you want (we used 45 degrees). For <code class="language-plaintext highlighter-rouge">factor</code>, choose some number less than 1, so that the subtrees are smaller than the original stick (by a factor of‚Ä¶well‚Ä¶<code class="language-plaintext highlighter-rouge">factor</code>). And for <code class="language-plaintext highlighter-rouge">rectangle</code>, use whatever arguments you want, but you want to be sure the rectangle is narrow and tall.</p> <p>Feel free to experiment. You can add little circles at the ends, for example to make something that looks vaguely like leaves. There‚Äôs no specific right answer we‚Äôre looking for on this one.</p> </div> </article> </body> </html>