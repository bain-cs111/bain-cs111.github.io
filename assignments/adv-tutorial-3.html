<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link id="github-css" rel="stylesheet" href="/assets/main.css"> </head> <title>Advanced Tutorial 3</title> <body class="two-column"> <div id="nav-bar"> <a href="#getting-started">Getting started</a><a href="#shorthand-for-lambda">Shorthand for Lambda</a><a href="#lets-write-an-interpreter">Let’s write an interpreter</a><a href="#part-1-interpreting-a-primitive-expression">Part 1</a><a href="#part-2-interpreting-an-arbitrary-expression">Part 2</a><a href="#part-3-interpreting-procedure-calls">Part 3</a><a href="#conclusion">Conclusion</a><a href="#getting-credit-for-your-work">Getting Credit for Your Work</a> </div> <article> <div class="main" style="max-height: 100vh;"> <object hidden="hidden" id="assignment-flag-custom"></object> <object hidden="hidden" id="canvas_id"></object> <object hidden="hidden" id="due_date">2024-10-16</object> <object hidden="hidden" id="canvas_assignment_group"></object> <object hidden="hidden" id="canvas_submission_types"></object> <object hidden="hidden" id="canvas_allowed_extensions"></object> <object hidden="hidden" id="canvas_points_possible"></object> <blockquote> <p>Note: If you’re completing the advanced tutorial remotely and plan to submit your RKT file, <strong>please make sure your file name has in it the string <code class="language-plaintext highlighter-rouge">adv</code></strong>, otherwise we will assume you are submitting the classic version of the tutorial.</p> </blockquote> <p>In this tutorial, we’ll look at some of the basics of how interpreters (the metaprograms that read and understand your programs) work. Also note that since you already have some programming knowledge, we’re going to revert back to more correct terminology for our “functions”: we’ll call them procedures in these advanced tutorials. <em>Technically</em>, a function is a procedure with no side effects (therefore everything we’ve done so far that’s not a special form is both a function and a procedure).</p> <p><a class="nu-button" href="https://bain-cs111.github.io/course-files/tutorials/adv_tutorial_3_template.zip" target="_blank"> Advance Tutorial 3 Starter Files <i class="fas fa-download"></i> </a></p> <hr> <h2 id="getting-started">Getting started</h2> <p>We told you that you can make a list containing the number 1, 2, and 3 by saying: <code class="language-plaintext highlighter-rouge">(list 1 2 3)</code>. That makes the list by running the <code class="language-plaintext highlighter-rouge">list</code> procedure and passing it the numbers 1, 2, and 3. The procedure then creates the new list and returns it.</p> <p>But there’s a simpler way of doing it. You can just say:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></div></div> <p>The single quote mark at the beginning tells Racket that everything between the parentheses is a list constant: it should just take all that data and package it up as a list. Because it knows that everything up to the matching close paren is data for the list, you can also use this to put lists in lists:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">((</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div></div> <p>The above means a list with two elements, the first of which is the list <code class="language-plaintext highlighter-rouge">(1 2 3)</code> and the second of which is the list <code class="language-plaintext highlighter-rouge">(4 5 6)</code>. And note that you don’t put additional quote marks inside; the one quote at the beginning is all.</p> <p>Quoting is easier but less general than calling list. If you say <code class="language-plaintext highlighter-rouge">(list a b c)</code>, you get a list with the values of the variables <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>, respectively. Since you’re calling a procedure, all the procedure’s arguments get run too, and so you can use this to make a list whose contents gets computed rather than being fixed. But if you say <code class="language-plaintext highlighter-rouge">'(a b c)</code>, it doesn’t look up the values of the variables a, b, and c, and put those in this list. Instead, it makes a list of the strings <code class="language-plaintext highlighter-rouge">a</code>,<code class="language-plaintext highlighter-rouge">b</code>, and <code class="language-plaintext highlighter-rouge">c</code>. Except they’re a special kind of string called a <code class="language-plaintext highlighter-rouge">symbol</code>. The only different between <code class="language-plaintext highlighter-rouge">strings</code> and <code class="language-plaintext highlighter-rouge">symbols</code> for our purposes is how you type them. You don’t have to put double-quotes around symbols when they’re inside quoted lists. If you want to type one outside of a quoted list, just put a single quote on it. So to type the symbol <code class="language-plaintext highlighter-rouge">a</code> outside a list, just say <code class="language-plaintext highlighter-rouge">'a</code>.</p> <p>Why am I telling you this? Because this is one of the things that makes people who like Racket like it a lot. Because notice that I can take any piece of Racket code whatsoever:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">a</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div> <p>And put a quote in front of it:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">'</span><span class="p">(</span><span class="k">define</span> <span class="nv">a</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></div></div> <p>And now it’s a data structure! That means it’s really easy to write metaprograms like interpreters, compilers, and debuggers in Racket because it’s easy to represent Racket source code as data.</p> <hr> <h2 id="shorthand-for-lambda">Shorthand for Lambda</h2> <p>So, you’re tired of writing the lambda word or symbol. Well I’ve got news for you. I’ve been lying to you this whole time. You don’t have to write the <code class="language-plaintext highlighter-rouge">lambda</code> if you’re creating an anonymous function.</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">function-name</span> <span class="nv">inputs</span> <span class="nv">…</span><span class="p">)</span>
   <span class="nv">output</span><span class="p">)</span>
</code></pre></div></div> <p>This defines a function named <code class="language-plaintext highlighter-rouge">function-name</code> with whatever inputs that comes next. We call this <strong>Sussman Form</strong> notation. It’s used extensively in our two auxillary textbooks and is just a more readable shorthand for:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">function-name</span>
  <span class="p">(</span><span class="k">λ</span> <span class="p">(</span><span class="nf">inputs</span> <span class="nv">…</span><span class="p">)</span> <span class="nv">output</span><span class="p">))</span>
</code></pre></div></div> <p>One thing to beware is that it sort of makes the part after <code class="language-plaintext highlighter-rouge">define</code>` look like a call to the function so just be careful. This is nothing but a notation nicety – Racket will actually take care of converting this thing to long-form (the one with the explicit lambda) before executing it.</p> <hr> <h2 id="lets-write-an-interpreter">Let’s write an interpreter</h2> <p>Okay, so now that we know how to represent source code as a nice data structure, let’s write some code to manipulate it. In particular, we’ll write a very simple interpreter for a subset of Racket.</p> <h3 id="dictionaries">Dictionaries</h3> <p>First, we need to have some way of keeping track of the values of the variables in our interpreted program. So we need a data structure that tracks the values of the different variables. We’ve been calling this data structure “the dictionary” in class, so let’s stick with that.</p> <p>We’ve written some code for you to represent a dictionary as a list of lists. There are better representations, but we’re just using <code class="language-plaintext highlighter-rouge">lists</code> and <code class="language-plaintext highlighter-rouge">structs</code> right now in class, so this will have to do. There’s one sublist for each variable and the sublist has the name of the variable first, and its value second.</p> <p>If you look in the <code class="language-plaintext highlighter-rouge">rkt</code> file, you’ll find definitions for <code class="language-plaintext highlighter-rouge">lookup</code>, which takes a variable name (a symbol) and a dictionary and returns the value of the named variable in the dictionary:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; Returns the value of variable-name within dictionary</span>
<span class="p">(</span><span class="nf">lookup</span> <span class="nv">variable-name</span>  <span class="nv">dictionary</span><span class="p">)</span>
</code></pre></div></div> <p>We’ve also made a dictionary you can use and put it in the variable <code class="language-plaintext highlighter-rouge">dictionary</code>. Next week, you’ll write code that makes new dictionaries, but for the moment, the one we gave you is enough to do this assignment.</p> <h3 id="how-an-interpreter-works">How an interpreter works</h3> <p>An interpreter takes a data structure that represents your code, and it walks through it, doing what it says to do. Since we’re interpreting a subset of Racket, that means our code is always an expression and running the code means getting the value of the expression. Moreover, we know that expressions come in different flavors with different rules for running them:</p> <ul> <li>Primitive expressions <ul> <li>Constants: are their own values</li> <li>Variable references: return the value of the variable in the dictionary</li> </ul> </li> <li>Compound expressions <ul> <li>procedure calls: run all the subexpressions, take the value of the first one (a procedure) and call it with the values of the others</li> <li>Special forms: we’ll get to these later</li> </ul> </li> </ul> <p>Our interpreter is going to be called with a data object representing an expression, it will then look at the object to see which <em>kind</em> of expression it’s running, and then use the right rule for that kind of expression.</p> <h3 id="preview">Preview</h3> <p>Let’s step through how this is going to run. We’re going to call our interpreter evaluate because that’s kind of tradition. When we say <code class="language-plaintext highlighter-rouge">(evaluate '(+ 1 2))</code>, the following sequence of calls is going to happen:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">evaluate</code> realizes it’s argument is a complex expression and so calls <code class="language-plaintext highlighter-rouge">(evaluate-complex-expression '(+ 1 2))</code>.</li> <li> <code class="language-plaintext highlighter-rouge">evaluate-complex-expression</code> realizes it’s argument is a procedure call and so calls <code class="language-plaintext highlighter-rouge">(evaluate-procedure-call '(+ 1 2))</code>.</li> <li> <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code> recursively calls <code class="language-plaintext highlighter-rouge">evaluate</code> on each of the subexpressions of the call: <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">1</code>, and <code class="language-plaintext highlighter-rouge">2</code> (in case you haven’t seen the term “recursive” before, it just refers to the fact that a function can call itself within its own definition). <ul> <li> <code class="language-plaintext highlighter-rouge">(evaluate '+)</code> calls <code class="language-plaintext highlighter-rouge">(evaluate-primitive-expression '+)</code>, which calls <code class="language-plaintext highlighter-rouge">(lookup '+ dictionary)</code>. <ul> <li>The value given for the variable named <code class="language-plaintext highlighter-rouge">'+</code> in the dictionary is just Racket’s normal <code class="language-plaintext highlighter-rouge">+</code> procedure, so this returns Racket’s <code class="language-plaintext highlighter-rouge">+</code> procedure.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">(evaluate 1)</code> calls <code class="language-plaintext highlighter-rouge">(evaluate-primitive-expression 1)</code>, which just returns <code class="language-plaintext highlighter-rouge">1</code>.</li> <li> <code class="language-plaintext highlighter-rouge">(evaluate 2)</code> calls <code class="language-plaintext highlighter-rouge">(evaluate-primitive-expression 2)</code>, which just returns <code class="language-plaintext highlighter-rouge">2</code>.</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code> now calls the value of the first expression (Racket’s normal boring <code class="language-plaintext highlighter-rouge">+</code> procedure) with <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code> as arguments, and gets <code class="language-plaintext highlighter-rouge">3</code> as a result.</li> </ul> <hr> <h2 id="part-1-interpreting-a-primitive-expression">Part 1. Interpreting a primitive expression</h2> <p>In our data structure for representing expressions, a constant expression like 10 is just represented as the number 10. Similarly, a string is represented by just the string itself. But references to variables are represented as a symbol holding the name of the variable. You can test whether something is a symbol or not using the <code class="language-plaintext highlighter-rouge">symbol?</code> procedure.</p> <p>Write a procedure <code class="language-plaintext highlighter-rouge">evaluate-primitive-expression</code>, that takes an object representing a primitive expression (that is, either a symbol or something else like a number) and returns its value using the rules above for primitive expressions. <em>Hint: the code for this is far simpler than the English text trying to explain what to write.</em></p> <p>By the way, the reason we call this thing <code class="language-plaintext highlighter-rouge">evaluate-primitive-expression</code> rather than <code class="language-plaintext highlighter-rouge">interpret-primitive-expression</code> is just that it’s traditional to call interpreters like this <code class="language-plaintext highlighter-rouge">evaluate</code> or <code class="language-plaintext highlighter-rouge">eval</code>. Evaluation is essentially a synonym for interpreting. You can test it by running things like</p> <ul> <li> <code class="language-plaintext highlighter-rouge">(evaluate-primitive-expression 1)</code> to test evaluating constants. This should return <code class="language-plaintext highlighter-rouge">1</code>!</li> <li> <code class="language-plaintext highlighter-rouge">(evaluate-primitive-expression 'b)</code> to test evaluating variable references. This should return the value of <code class="language-plaintext highlighter-rouge">b</code> in the dictionary, which is <code class="language-plaintext highlighter-rouge">2</code>.</li> </ul> <hr> <h2 id="part-2-interpreting-an-arbitrary-expression">Part 2. Interpreting an arbitrary expression</h2> <p>Any expression that isn’t a primitive expression is a complex expression and has parentheses in the source code. And when you quote that code, you get a list. So any complex expression is represented as a list.</p> <p>Write a procedure <code class="language-plaintext highlighter-rouge">evaluate</code>, that takes an object representing an expression (complex or primitive) and uses either <code class="language-plaintext highlighter-rouge">evaluate-primitive-expression</code> or <code class="language-plaintext highlighter-rouge">evaluate-complex-expression</code> to run it, depending on whether it’s a list. Note that we haven’t written <code class="language-plaintext highlighter-rouge">evaluate-complex-expression</code> yet, so you can’t test it yet.</p> <p>For the moment, we’re just going to have our interpreter handle procedure calls, but not other kinds of complex expressions. So write <code class="language-plaintext highlighter-rouge">evaluate-complex-expression</code> to just call <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code> which we’ll tackle in the next step.</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">evaluate-complex-expression</span> <span class="nv">exp</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">evaluate-procedure-call</span> <span class="nv">exp</span><span class="p">))</span>
</code></pre></div></div> <p>We’ll add support for things like <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">lambda</code> next week.</p> <hr> <h2 id="part-3-interpreting-procedure-calls">Part 3. Interpreting procedure calls</h2> <p>Okay, so now we want to write <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code>. This is going to take a list representing the procedure call expression and run that expression. For example, if the source code was <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>, <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code> will get called with the list <code class="language-plaintext highlighter-rouge">'(+ 1 2)</code>, i.e. a three element list whose elements are the symbol <code class="language-plaintext highlighter-rouge">+</code>, and the numbers <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">2</code>, respectively:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; evaluate-procedure-call: list -&gt; any</span>
<span class="c1">;; Take the list representing a procedure call, run it, and return the</span>
<span class="c1">;; result.</span>
</code></pre></div></div> <p>Great! How do we run a procedure call? First we run all the subexpressions. Since our call is a list, the subexpressions are the elements of the list. So we need to run all the elements of the list and get their results back. So ask yourself:</p> <ul> <li>What is the name of a procedure you’ve written that you can call with an arbitrary expression and that will run it and return the result?</li> <li>What procedure did we teach you about in class that lets you run a procedure on all the elements of a list and give you back a list of the results?</li> <li>What special form did we tell you about to take the result of an expression and stash it in a local variable?</li> </ul> <p>Start by writing a definition for <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code> that takes the list passed to it and runs all the elements of the list and stashes a list of the results in a local variable.</p> <p>Now you have a list of the results of all the subexpressions. The rest of the rule for running a procedure call is to take the result of the first subexpression, which had better be a procedure, and call it with the results of the rest as inputs.</p> <p>You can use <code class="language-plaintext highlighter-rouge">first</code> to get the value of the first subexpression, and <code class="language-plaintext highlighter-rouge">rest</code> to get the values of the others. And you can use <code class="language-plaintext highlighter-rouge">apply</code>, which was discussed in the pre-recorded lecture, to call a procedure and pass it arguments taken from a list. So put those together to finish off your definition of <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code>, and with it your interpreter.</p> <hr> <h2 id="conclusion">Conclusion</h2> <p>That’s all you have to do to write the minimum possible interpreter. It’s basically just a glorified calculator. Once of its glaring deficiencies is that it doesn’t have <code class="language-plaintext highlighter-rouge">lambda</code>, so you don’t have any way of defining a procedure, and so you can’t ever call anything except one of Racket’s procedures that you stashed in the dictionary in advance. But we’ll add <code class="language-plaintext highlighter-rouge">lambda</code> and <code class="language-plaintext highlighter-rouge">if</code> next week.</p> <hr> <h2 id="getting-credit-for-your-work">Getting Credit for Your Work</h2> <p>Find one other person in your group that is finished and peer review each other’s work. Here are the things to check:</p> <ol> <li>Does their code look readable and neat?</li> <li>Can you understand what their code does by reading it?</li> <li>How was their solution different from yours (if at all)?</li> <li>Does their program run and generate the correct test images?</li> </ol> <p>Once you’ve each taken a look, take a second to debrief. Anything either of you found difficult? Easy? Fun? Mind-blowing? Once you’ve debriefed, <strong>both of you should fill out this</strong> <a href="https://docs.google.com/forms/d/e/1FAIpQLSd6RMZwNmhSSENCqJVfUE7jwkg9IcBXgQgnsJWur7YIM9yy2g/viewform?usp=sf_link" target="_blank" rel="external nofollow noopener">attendance Google Form</a>. <strong>NOTE: You will need the NetID of the person’s whose code you reviewed.</strong></p> <p><em>If you’re submitting remotely</em>, you MUST submit your completed tutorial to Canvas. Make sure you have correctly defined all the functions.</p> <p>Before turning your assignment in, <strong>run the file one last time</strong> to make sure that it runs properly and doesn’t generate any exceptions, and all the tests pass. Definitely make sure to read the Autograder FAQs on Canvas (under Class Resources).</p> </div> </article> </body> </html>