<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link id="github-css" rel="stylesheet" href="/assets/main.css"> </head> <title>Building Racket Interpreter in Racket, pt 2</title> <body class="two-column"> <div class="wrapper"> <div id="sidebar" class="sidebar sticky-frame"> <ol class="side-menu"> <li> <a href="#updates-from-last-weeks-template">Updates from Last Week’s Template</a><ol> <li><a href="#sussman-form">Sussman Form</a></li> <li><a href="#more-dictionaries">More dictionaries</a></li> <li><a href="#a-new-kind-of-procedure">A new kind of procedure</a></li> </ol> </li> <li><a href="#adding-if-expressions">Adding <code class="language-plaintext highlighter-rouge">if</code> expressions</a></li> <li><a href="#adding-lambda-expressions">Adding <code class="language-plaintext highlighter-rouge">lambda</code> expressions</a></li> <li><a href="#reimplementing-procedure-calls">Reimplementing procedure calls</a></li> <li><a href="#this-is-almost-a-complete-programming-language">This is almost a complete programming language</a></li> <li><a href="#getting-credit-for-your-work">Getting Credit for Your Work</a></li> </ol> </div> <article style="padding-left: 1em;"> <div class="main"> <object hidden="hidden" id="assignment-flag-custom"></object> <object hidden="hidden" id="canvas_id"></object> <object hidden="hidden" id="due_date">2024-10-23</object> <object hidden="hidden" id="canvas_assignment_group"></object> <object hidden="hidden" id="canvas_submission_types"></object> <object hidden="hidden" id="canvas_allowed_extensions"></object> <object hidden="hidden" id="canvas_points_possible"></object> <blockquote> <p>Note: If you’re completing the advanced tutorial remotely and plan to submit your RKT file, <strong>please make sure your file name has in it the string <code class="language-plaintext highlighter-rouge">adv</code></strong>, otherwise we will assume you are submitting the classic version of the tutorial.</p> </blockquote> <p>In this tutorial, we’ll add support for <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">lambda</code> to the interpreter.</p> <p><a class="nu-button" href="https://bain-cs111.github.io/course-files/tutorials/adv_tutorial_4_template.zip" target="_blank"> Advance Tutorial 4 Starter Files <i class="fas fa-download"></i> </a></p> <hr> <h2 id="updates-from-last-weeks-template">Updates from Last Week’s Template</h2> <p>Note, we’ve changed the code for the old interpreter a little from last week.</p> <h3 id="sussman-form">Sussman Form</h3> <p>The following is part of the language we will use to WRITE our interpreter but does not need to be processed by the interpreter itself.</p> <p>So you know how we have been using <code class="language-plaintext highlighter-rouge">lambda</code> to denote the creation of functions? Even when we make named functions? You don’t actually have to do that. Instead there’s a shortcut (in programming language design, this is sometimes called <em>syntactic sugar</em>).</p> <p>Say we want to make the function <code class="language-plaintext highlighter-rouge">my-sum</code> that takes as input a list of numbers and returns the sum. Before we’d do it by saying:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">my-sum</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a-list</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">apply</span> <span class="nv">+</span> <span class="nv">a-list</span><span class="p">)))</span>
</code></pre></div></div> <p>Well there’s actually a short hand for this which is called “Sussman form” (named after one of the authors of our auxiliary textbooks.)</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">my-sum</span> <span class="nv">a-list</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">apply</span> <span class="nv">+</span> <span class="nv">a-list</span><span class="p">))</span>
</code></pre></div></div> <p>In other words, the <code class="language-plaintext highlighter-rouge">lambda</code> symbol itself can be skipped. Instead, we just say <code class="language-plaintext highlighter-rouge">(define (func-name input-1 input-2 ...) output-expression)</code> as shorthand. You’ll see this in the template file. Sussman form is equivalent to what we have been using (actually when Racket processes your code it transpiles it to include that lambda symbol) and is literally just an optional shorthand you can use.</p> <h3 id="more-dictionaries">More dictionaries</h3> <p>Since we’re going to be adding <code class="language-plaintext highlighter-rouge">lambda</code> expressions to the interpreter, and lambdas have arguments (variables to hold the inputs to the procedure), we need some way to let the dictionary change over time. To do that, we’ve modified the old interpreter so that most of the procedures take a dictionary as an additional input. That way we can use different dictionaries in different contexts.</p> <p>We also added a new procedure, <code class="language-plaintext highlighter-rouge">extend-dictionary</code>, that takes a list of variables, a list of values for those variables, and an existing dictionary, and returns a new dictionary that has all the new variables and values, followed by all the old ones.</p> <h3 id="a-new-kind-of-procedure">A new kind of procedure</h3> <p>In last week’s interpreter, when you ran <code class="language-plaintext highlighter-rouge">(+ 1 1)</code>, the interpreter evaluated <code class="language-plaintext highlighter-rouge">+</code> and got back Racket’s <code class="language-plaintext highlighter-rouge">+</code> procedure. So all it had to do to finish the procedure call was to use apply to run Racket’s <code class="language-plaintext highlighter-rouge">+</code> procedure.</p> <p>However, now we have to allow for the possibility that when the interpreter runs something like <code class="language-plaintext highlighter-rouge">(f 1)</code>, that <code class="language-plaintext highlighter-rouge">f</code> will be the result of a lambda expression like <code class="language-plaintext highlighter-rouge">(lambda (x) (+ x 1))</code>. In that case, we run the procedure call <code class="language-plaintext highlighter-rouge">(f 1)</code> by calling evaluate on the source code <code class="language-plaintext highlighter-rouge">(+ x 1)</code> from the lambda, only now in a dictionary in which <code class="language-plaintext highlighter-rouge">x</code> is set to <code class="language-plaintext highlighter-rouge">1</code>.</p> <p>All of this means we need a new kind of data object to hold that source code in it so when the interpreter tries to call it, it can both recognize that it’s not a built-in Racket procedure, and also know what source code it needs to run. These data objects are traditionally called <strong><em>closures</em></strong> (you’ll learn more about these in COMP_SCI 321), but in our code, we’ve called them <code class="language-plaintext highlighter-rouge">interpreted-procedures</code> since that’s more explicit. There’s a <code class="language-plaintext highlighter-rouge">define-struct</code> in the code for interpreted procedures. They have three fields:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">inputs</code>: a list of the names of the variables for the procedure’s arguments</li> <li> <code class="language-plaintext highlighter-rouge">result</code>: the expression to run to compute the output of the procedure</li> <li> <code class="language-plaintext highlighter-rouge">dictionary</code>: the dictionary that was in use when the lambda was executed to make this interpreted-procedure. Remembering the dictionary will allow a lambda to use the local variables of the code around it.</li> </ul> <p>So for example, if we run <code class="language-plaintext highlighter-rouge">(lambda (x) (+ x 1))</code> while the dictionary is <code class="language-plaintext highlighter-rouge">((x 1) (y 2))</code>, we’ll get back an <code class="language-plaintext highlighter-rouge">interpreted-procedure</code> whose:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">inputs</code> are <code class="language-plaintext highlighter-rouge">'(x)</code> </li> <li> <code class="language-plaintext highlighter-rouge">result</code> is <code class="language-plaintext highlighter-rouge">'(+ x 1)</code> </li> <li> <code class="language-plaintext highlighter-rouge">dictionary</code> is <code class="language-plaintext highlighter-rouge">'((x 1) (y 2))</code>.</li> </ul> <p>Take a moment and read through the code. We’ve marked what’s been added, and what’s been changed.</p> <hr> <h2 id="adding-if-expressions">Adding <code class="language-plaintext highlighter-rouge">if</code> expressions</h2> <p>In our old version, <code class="language-plaintext highlighter-rouge">evaluate-complex</code> always called <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code>. Write a new version of <code class="language-plaintext highlighter-rouge">evaluate-complex</code> that calls <code class="language-plaintext highlighter-rouge">evaluate-if</code>, when the expression starts with the symbol <code class="language-plaintext highlighter-rouge">if</code>, and otherwise calls <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code>. You can check if a value is the symbol <code class="language-plaintext highlighter-rouge">if</code> by saying:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">eq?</span> <span class="nv">value</span> <span class="ss">'if</span><span class="p">)</span>
</code></pre></div></div> <p>Now all you have to do is write <code class="language-plaintext highlighter-rouge">evaluate-if</code>. We have a skeleton for it in the code. Fill it in.</p> <hr> <h2 id="adding-lambda-expressions">Adding <code class="language-plaintext highlighter-rouge">lambda</code> expressions</h2> <p>Great. Now modify <code class="language-plaintext highlighter-rouge">evaluate-complex</code> so that if the expression starts with <code class="language-plaintext highlighter-rouge">lambda</code>, it calls <code class="language-plaintext highlighter-rouge">evaluate-lambda</code>. Then write <code class="language-plaintext highlighter-rouge">evaluate-lambda</code>. Again, we have a skeleton for you to start from in the code. Remember that <code class="language-plaintext highlighter-rouge">evaluate-lambda</code> is going to return an <code class="language-plaintext highlighter-rouge">interpreted-procedure</code> object, so it needs to call <code class="language-plaintext highlighter-rouge">make-interpreted-procedure</code> with values for the <code class="language-plaintext highlighter-rouge">inputs</code>, the <code class="language-plaintext highlighter-rouge">result</code>, and the <code class="language-plaintext highlighter-rouge">dictionary</code>.</p> <hr> <h2 id="reimplementing-procedure-calls">Reimplementing procedure calls</h2> <p>As before, procedure calls are implemented by first recursively evaluating all the subexpressions, then calling the value of the procedure expression on the values of the argument expressions. However, this time we have two kinds of procedures to worry about: built-in, primitive Racket procedures, like <code class="language-plaintext highlighter-rouge">+</code>; and <code class="language-plaintext highlighter-rouge">interpreted-procedures</code> created by <code class="language-plaintext highlighter-rouge">lambda</code>.</p> <p>Write <code class="language-plaintext highlighter-rouge">evaluate-procedure-call</code> so that it recursively finds the values of the subexpressions, as before. But now, instead of always using <code class="language-plaintext highlighter-rouge">apply</code> to run the procedure on the arguments, it instead calls <code class="language-plaintext highlighter-rouge">apply-interpreted-procedure</code>, <strong>if</strong> the procedure is an <code class="language-plaintext highlighter-rouge">interpreted-procedure object</code>. Otherwise, it can use <code class="language-plaintext highlighter-rouge">apply</code> as before.</p> <p>Finally, write <code class="language-plaintext highlighter-rouge">apply-interpreted-procedure</code>. It should make a new dictionary using the argument names from the <code class="language-plaintext highlighter-rouge">interpreted-procedure</code> object and the argument values being passed to it, as well as the dictionary from the <code class="language-plaintext highlighter-rouge">interpreted-procedure</code> object. Then it can just call <code class="language-plaintext highlighter-rouge">evaluate</code> on the result expression from the <code class="language-plaintext highlighter-rouge">interpreted-procedure</code> object, and the new dictionary.</p> <hr> <h2 id="this-is-almost-a-complete-programming-language">This is almost a complete programming language</h2> <p>The one thing we haven’t implemented is <code class="language-plaintext highlighter-rouge">define</code>, which will have to wait until we get to imperative programming. That’s why we have test cases that look like:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">check-expect</span> <span class="p">(</span><span class="nf">evaluate</span> <span class="o">'</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
                          <span class="mi">1</span><span class="p">)</span>
                        <span class="nv">dictionary</span><span class="p">)</span>
              <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div> <p>It’s the only way we can test running an interpreted procedure for the moment, but we’ll get to <code class="language-plaintext highlighter-rouge">define</code> soon.</p> <p>Not having <code class="language-plaintext highlighter-rouge">define</code> also means we also don’t have <em>recursion</em> itself (in our constructed language), which is a serious bummer. There is technically a way of implementing recursion using only what we have here. It’s called the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus" rel="external nofollow noopener" target="_blank">Y combinator</a>, and there’s a famous <a href="https://en.wikipedia.org/wiki/Y_Combinator" rel="external nofollow noopener" target="_blank">startup accelerator</a> named after it. But both are way outside the scope of this course.</p> <hr> <h2 id="getting-credit-for-your-work">Getting Credit for Your Work</h2> <p>If you’re in class make sure to fill out the attendance form on the regular tutorial page before leaving. You don’t need to submit a <code class="language-plaintext highlighter-rouge">rkt</code> file. Your attendance will be posted on Canvas by around 5pm today.</p> </div> </article> </div> </body> </html>