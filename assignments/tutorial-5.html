<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link id="github-css" rel="stylesheet" href="/assets/main.css"> </head> <title>Tutorial 5</title> <body class="two-column"> <div id="nav-bar"> <a href="#submitting">Submitting</a><a href="#getting-started">Getting Started</a><a href="#part-1-power">Part 1</a><a href="#part-2-poweriter">Part 2</a><a href="#interlude---cond">Interlude - cond</a><a href="#part-3-countiter">Part 3</a><a href="#part-4-any">Part 4</a><a href="#part-5-every">Part 5</a> </div> <article> <div class="main" style="max-height: 100vh;"> <object hidden="hidden" id="assignment-flag-custom"></object> <object hidden="hidden" id="canvas_id">1482915</object> <object hidden="hidden" id="due_date">2024-10-25</object> <object hidden="hidden" id="canvas_assignment_group">Tutorials</object> <object hidden="hidden" id="canvas_submission_types">online_upload</object> <object hidden="hidden" id="canvas_allowed_extensions">rkt</object> <object hidden="hidden" id="canvas_points_possible">100</object> <blockquote> <p>Note: Sadly, there’s no advanced tutorial today. We’ll resume working on our interpreter next week! If you have an idea that you’d like to explore more in either interpreting or functional programming, come find me and I can give you some things to investigate!</p> </blockquote> <h2 id="submitting">Submitting</h2> <p><mark>Regardless of how you choose to complete the assignment, you MUST submit the file you worked on to Canvas.</mark></p> <h3 id="if-you-are-submitting-remotely">IF YOU ARE SUBMITTING REMOTELY</h3> <p><em>If you’re submitting remotely</em>, your submitted file will be graded for completeness and correctness via an autograder. Make sure your functions are named as the assignment specifies <mark>exactly</mark>.</p> <h3 id="if-you-are-in-class-or-at-an-alt-tutorial">IF YOU ARE IN CLASS OR AT AN ALT TUTORIAL</h3> <p>Then your file will be graded for participation (i.e. it’s okay if you haven’t finished the entire thing because you may have spent time asking a question; helping a friend; etc.) along with what we call a ‘peer review.’ Find one other person in your group that is finished and peer review each other’s work. Here are the things to check:</p> <ol> <li>Does their code look readable and neat?</li> <li>Can you understand what their code does by reading it?</li> <li>How was their solution different from yours (if at all)?</li> <li>Does their program run and generate the correct results?</li> </ol> <p>Once you’ve debriefed, <mark><b>both of you should fill out this</b> <a href="https://docs.google.com/forms/d/e/1FAIpQLSd6RMZwNmhSSENCqJVfUE7jwkg9IcBXgQgnsJWur7YIM9yy2g/viewform?usp=sf_link" target="_blank" rel="external nofollow noopener">attendance Google Form</a>. NOTE: You will need the NetID of the person's whose code you reviewed. This form will only be available near the end of the tutorial session.</mark></p> <hr> <h2 id="getting-started">Getting Started</h2> <p>Today we’ll continue to practice recursion with a specific focus on a specific type of recursion we call <strong>iterative recursion</strong>.</p> <p>Like last time, there are no template files for this Tutorial so you’ll need to start from a blank DrRacket file.</p> <p>After you’ve got a blank document open, might as well save it with a good sensible name somewhere on your computer where you store important docs.</p> <hr> <h2 id="part-1-power">Part 1. <code class="language-plaintext highlighter-rouge">power</code> </h2> <p>Write a function, <code class="language-plaintext highlighter-rouge">power</code>, that raises a number to a power: <code class="language-plaintext highlighter-rouge">(power a b)</code> should return <code class="language-plaintext highlighter-rouge">a^b</code>. So <code class="language-plaintext highlighter-rouge">(power 4 2)</code> is <code class="language-plaintext highlighter-rouge">4^2 = 16</code>, <code class="language-plaintext highlighter-rouge">(power 4 3)</code> is <code class="language-plaintext highlighter-rouge">4^3 = 64</code>, …, etc. Remember that in math class, for any <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">(power a 0)</code> is 1 (anything to the zeroth power is 1) and <code class="language-plaintext highlighter-rouge">(power a 1)</code> is <code class="language-plaintext highlighter-rouge">a</code>. We won’t worry about fractional or negative powers.</p> <p>Time for our subgoals!</p> <p>What is the type of <code class="language-plaintext highlighter-rouge">power</code> (that is, what is its type signature, the types of its input and output)?</p> <p>Step 1. What is the purpose statement for it?</p> <p>Step 2. What should the base case be (aka the “easy case”) for the recursion? Note that here we have two inputs to the function. Which one would we be changing as we recurse? Or would we change both of them?</p> <p>Step 3. Use the usual template for the base case:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span> <span class="nv">test-for-base-case</span>
    <span class="nv">answer-for-base-case</span>
    <span class="nv">TODO</span><span class="p">)</span>
</code></pre></div></div> <p>Where <code class="language-plaintext highlighter-rouge">test-for-base-case</code> is something that looks at the input to the function and determines if it’s the base case input and <code class="language-plaintext highlighter-rouge">answer-for-base-case</code> is the answer for the base case. We’ll fill in <code class="language-plaintext highlighter-rouge">TODO</code> in a minute.</p> <p>Step 4. What’s the recursive case? Remember the recursive case is what runs when the input is too hard to be handled by the base case. We call ourselves on a version of the input that’s one step closer to being the base case. Then we take the answer to that and turn it into the answer for the original problem. So you can to decide two things:</p> <ul> <li>How do you make the input to power be closer to your base case?</li> <li>If you had the answer for the easier input, how would you use it to solve for the original input?</li> </ul> <p>Step 5. Now fill in the part in your code that says TODO:</p> <ul> <li>Write your recursive call, i.e. <code class="language-plaintext highlighter-rouge">(power easier-inputs)</code> where <code class="language-plaintext highlighter-rouge">easier-inputs</code> are whatever the easier version of the inputs are.</li> <li>Change it to <code class="language-plaintext highlighter-rouge">(fixit (power easier-input))</code> where <code class="language-plaintext highlighter-rouge">fixit</code> is something that changes the answer to <code class="language-plaintext highlighter-rouge">(power easier-input)</code> into the answer for the original input.</li> </ul> <hr> <h2 id="part-2-poweriter">Part 2. <code class="language-plaintext highlighter-rouge">power/iter</code> </h2> <p>Now write <code class="language-plaintext highlighter-rouge">power</code> as an iterative recursion. Start by writing a helper function, <code class="language-plaintext highlighter-rouge">power-helper</code>, that takes an extra accumulator input:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">power-helper</span> <span class="nv">number</span> <span class="nv">exponent</span> <span class="nv">accumulator</span><span class="p">)</span>
   <span class="o">...</span><span class="nv">stuff</span><span class="o">...</span><span class="p">)</span>
</code></pre></div></div> <blockquote> <p>Note: Function definition look weird? Checkout the section on Sussman form from Tutorial 4!</p> </blockquote> <p>And returns the answer (<code class="language-plaintext highlighter-rouge">number</code> raised to <code class="language-plaintext highlighter-rouge">exponent</code>). To do that, first answer these questions for yourself:</p> <ul> <li>Remember that the <code class="language-plaintext highlighter-rouge">accumulator</code> stores the partial answer. What is the answer you’re ultimately trying to compute (in English)?</li> <li>What would a partial answer be like for this problem?</li> <li>What should the initial value of the accumulator be?</li> <li>We’ll use the same base case as before (when input is zero). What should it return in that case?</li> <li>Then how do we write the recursive case?</li> <li>Only once you’ve answered all these questions should you actually write the code for the function!</li> </ul> <p>And finally, write the definition of power itself:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">power/iter</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">number</span> <span class="nv">exponent</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">power-helper</span> <span class="o">...</span><span class="nv">fill</span> <span class="nv">this</span> <span class="nv">in</span><span class="o">...</span><span class="p">)))</span>
</code></pre></div></div> <p><a href="https://bain-cs111.github.io/course-files/tutorials/tutorial_5/power_walkthrough.rkt">Having trouble? See if this walkthrough step-by-step helps.</a></p> <hr> <h2 id="interlude---cond">Interlude - <code class="language-plaintext highlighter-rouge">cond</code> </h2> <p>So sometimes you want to do conditionals that have <em>more</em> than two branches. For instance, “if the number i’m looking at is 6, then do this, otherwise if it’s 5 then do this, if it’s 4 then do this, etc.”.</p> <p>You can totally do that by chaining <code class="language-plaintext highlighter-rouge">if</code> statements together…but it gets cumbersome pretty quickly. When you find yourself in that sort of situation, it’s better to use <code class="language-plaintext highlighter-rouge">cond</code>. <code class="language-plaintext highlighter-rouge">cond</code> is another special form that allows us to test multiple conditions and then do actions based on those tests.</p> <p>When you just want to see if a <code class="language-plaintext highlighter-rouge">test</code> returns <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> and do two different actions, <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">cond</code> behave exactly the same. They just use different notation:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">if</span> <span class="nv">test</span>
    <span class="nv">do-this-if-test-true</span>
    <span class="nv">do-this-if-test-false</span><span class="p">)</span>
</code></pre></div></div> <p>is the same as this:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">cond</span> <span class="p">[</span><span class="nf">test</span> <span class="nv">do-this-if-test-true</span><span class="p">]</span>
      <span class="p">[</span><span class="nf">else</span> <span class="nv">do-this-if-test-false</span><span class="p">])</span>
</code></pre></div></div> <p>Notice there are a couple special parts of <code class="language-plaintext highlighter-rouge">cond</code>’s notation. The first is that you have to put square brackets before and after each test - action pair. The second is that we put <code class="language-plaintext highlighter-rouge">else</code> as the “test” for the last branch. You can think of <code class="language-plaintext highlighter-rouge">else</code> as a function that returns true <strong>only if</strong> all the previous tests return false.</p> <p>Like I said, you don’t need <code class="language-plaintext highlighter-rouge">cond</code> for anything <strong>yet</strong>. But it is very useful for lots of branches in a program:</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">cond</span> <span class="p">[</span><span class="nf">test</span> <span class="nv">do-this-if-test-true</span><span class="p">]</span>
      <span class="p">[</span><span class="nf">test-2</span> <span class="nv">otherwise-do-this-if-test-2-true</span><span class="p">]</span>
      <span class="p">[</span><span class="nf">test-3</span> <span class="nv">otherwise-do-this-if-test-3-true</span><span class="p">]</span>
      <span class="p">[</span><span class="nf">else</span> <span class="nv">otherwise-just-do-this</span><span class="p">])</span>
</code></pre></div></div> <p>See if you can use <code class="language-plaintext highlighter-rouge">cond</code> (with 2 branches) instead of using <code class="language-plaintext highlighter-rouge">if</code>s for the next couple of problems!</p> <hr> <h2 id="part-3-countiter">Part 3. <code class="language-plaintext highlighter-rouge">count/iter</code> </h2> <p>Now write the count function from last time (with a new name):</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">count/iter:</span> <span class="p">(</span><span class="nf">X</span> <span class="nv">-&gt;</span> <span class="nv">Boolean</span><span class="p">)</span> <span class="p">(</span><span class="nf">listof</span> <span class="nv">X</span><span class="p">)</span> <span class="nv">-&gt;</span> <span class="nv">number</span>
</code></pre></div></div> <p>As an iterative recursion. Again, start by writing the helper function that returns the answer (the number of elements of <code class="language-plaintext highlighter-rouge">list</code> that satisfy the predicate).</p> <div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">count-helper</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">predicate</span> <span class="nv">list</span> <span class="nv">accumulator</span><span class="p">)</span>
  <span class="o">...</span><span class="nv">stuff</span><span class="o">...</span><span class="p">))</span>
</code></pre></div></div> <p>To do that:</p> <ul> <li>Remember that the <code class="language-plaintext highlighter-rouge">accumulator</code> stores the partial answer. What is the answer you’re ultimately trying to compute (in English)?</li> <li>What would a partial answer be like for this problem?</li> <li>What should the initial value of the accumulator be?</li> <li>We’ll use the same base case as before (when the list is empty). What should it return in that case?</li> <li>And how do we write the recursive case then?</li> <li>Now write the code for the helper!</li> </ul> <p>And finally, write the definition of <code class="language-plaintext highlighter-rouge">count/iter</code> itself.</p> <hr> <h2 id="part-4-any">Part 4. <code class="language-plaintext highlighter-rouge">any?</code> </h2> <p>Write a function, <code class="language-plaintext highlighter-rouge">(any? predicate list)</code> that returns <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">predicate</code> returns <code class="language-plaintext highlighter-rouge">true</code> for any element of <code class="language-plaintext highlighter-rouge">list</code>, otherwise it returns <code class="language-plaintext highlighter-rouge">false</code>.</p> <blockquote> <p><strong>Note</strong>: Yes, this is the same as <code class="language-plaintext highlighter-rouge">ormap</code>, we’re just naming it <code class="language-plaintext highlighter-rouge">any?</code> because <code class="language-plaintext highlighter-rouge">ormap</code> is already in use and also because <code class="language-plaintext highlighter-rouge">ormap</code> does not really make sense to someone that isn’t already thinking boolean-ly.</p> </blockquote> <ul> <li>What should the base case be (in English)?</li> <li>What should the recursive case be (in English)?</li> </ul> <p>Note that you may write this as an iterative or non-iterative recursion. However, be aware that the iterative version doesn’t need an extra accumulator variable. You can write it with just two arguments, without needing to do a <code class="language-plaintext highlighter-rouge">fixup</code> step to the answer from the recursive call.</p> <blockquote> <p>Note: Think about why this might be the case. Once you find one element that satisfies your <code class="language-plaintext highlighter-rouge">predicate</code> do you really care if the rest do?</p> </blockquote> <p>We recommend just writing it and then looking at the result to see whether you ended up with an iterative or non-iterative version.</p> <hr> <h2 id="part-5-every">Part 5. <code class="language-plaintext highlighter-rouge">every?</code> </h2> <p>Write a function, <code class="language-plaintext highlighter-rouge">(every? predicate list)</code> that returns true if <code class="language-plaintext highlighter-rouge">predicate</code> returns <code class="language-plaintext highlighter-rouge">true</code> for every element of <code class="language-plaintext highlighter-rouge">list</code>, otherwise it returns <code class="language-plaintext highlighter-rouge">false</code>.</p> <blockquote> <p>Note: Yep, you guessed it…it’s <code class="language-plaintext highlighter-rouge">andmap</code>! Think carefully about how this is different from Problem 4. Once you find one element that <em>does not</em> satisfy your predicate, do you really care if the rest do or do not?</p> </blockquote> <ul> <li>What should the base case be (in English)?</li> <li>What should the recursive case be (in English)?</li> </ul> <p>You can write this as an iterative or non-iterative recursion.</p> </div> </article> </body> </html>